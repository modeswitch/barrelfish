/*
 * Copyright (c) 2009, 2010, ETH Zurich.
 * All rights reserved.
 *
 * This file is distributed under the terms in the attached LICENSE file.
 * If you do not find this file, copies can be found by writing to:
 * ETH Zurich D-INFK, Haldeneggsteig 4, CH-8092 Zurich. Attn: Systems Group.
 */

/**
    Hamlet input file.

    This file defines the Barrelfish capability type system.

    (Meta-)Comments about the syntax are enclosed between /** ... **/
    Comments of the Hamlet language are enclosed between /* ... */
**/


/** cap_raw_word maps to CAP_RAW_WORD,
    as defined in include/barrelfish/kpi/capabilities.h **/

/* Maximum words in the type-specific part of a capability
   representation: */
/* XXX: FIXME: x86-64-specific! */
param cap_raw_word 3;


/** We can define some constants using the "define" construct **/

/* XXX: these must match the corresponding OBJBITS definitions in barrelfish_kpi/capabilities.h */

/* Size of CNode entry: */
define cnode_size 6;
/* Size of DCB: */
define dispatcher_size 9;
/* Size of (x86_64) VNode: */
define vnode_size 12; /* BASE_PAGE_BITS */

/** 
    The capabilities of the whole system are listed thereafter.
    The minimal definition consists of a name and an empty body. 
**/

cap Null {
     /* Null/invalid object type */
     is_never_copy;
};

cap PhysAddr {
     /* Physical address range (root of cap tree) */
    
     /**
       When a cap can *uniquely* retype to others,
       we specify that using "retype_to".

       This is used to implement "is_well_founded" and
       "is_revoked_first",
       in kernel/capabilities.c

       In order to implement "is_ancestor",
       in kernel/mbc.c,
       we need to specify which fields of the child caps are to be
       compared for inclusion. When provided a tuple (base, offset),
       the formula is:
       "parent->base >= child->base &&
        child->base + (1ul << child->offset) <= 
	  parent->base + (1ul << parent->offset)"
     **/
 
     retype_to { 
	 RAM: { base, bits },
	 DevFrame: { base, bits },
	 PhysAddr: { base, bits }
     };

     /**
       For a populated cap, we need to give the type and name of each
       of its fields, such as:
       "genpaddr base;" for instance

       In order to implement "is_copy", 
       in kernel/mdb.c,
       we need to specify which fields are part of the equality
       relation, using the command:
       "eq genpaddr base;" for instance
     **/

     eq genpaddr base;	/* Base address of untyped region */
     eq uint8 bits;	/* Address bits that untyped region bears */

};


/** The following caps are similar to the previous one **/

cap RAM {
     /* RAM memory object */

     retype_to {
         RAM: { base, bits },
	 Frame: { base, bits },
	 Dispatcher: { mem_to_phys(dcb), dispatcher_size },
	 CNode: { cnode, cnode_size + bits }, 
	 VNode_x86_64_pml4: { base, vnode_size },
	 VNode_x86_64_pdpt: { base, vnode_size },
	 VNode_x86_64_pdir: { base, vnode_size },
	 VNode_x86_64_ptable: { base, vnode_size },
	 VNode_x86_32_pdpt: { base, vnode_size },
	 VNode_x86_32_pdir: { base, vnode_size },
	 VNode_x86_32_ptable: { base, vnode_size },
	 VNode_ARM_l1:      { base, vnode_size },
	 VNode_ARM_l2:      { base, vnode_size }
     };

     eq genpaddr base;	/* Base address of untyped region */
     eq uint8 bits;	/* Address bits that untyped region bears */
};


cap CNode {
     /* CNode table, stores further capabilities */

     eq lpaddr cnode;	/* Base address of CNode */
     eq uint8 bits;     /* Number of bits this CNode resolves */
     caprights rightsmask;
     uint8 guard_size;  /* Number of bits in guard */
     caddr guard;       /* Bitmask already resolved when reaching this CNode */

};

cap FCNode {
     /* Foreign CNode capability */

     eq genpaddr cnode;	 /* Base address of CNode */
     eq uint8 bits;    	 /* Number of bits this CNode resolves */
     caprights rightsmask;
     eq uint8 core_id; 	 /* The core the cap is local on */
     uint8 guard_size; 	 /* Number of bits in guard */
     caddr guard;        /* Bitmask already resolved when reaching this CNode */
};

/** Dispatcher is interesting is several ways. **/

cap Dispatcher {
     /* Dispatcher */

     /** 
       The Dispatcher is a special case that can be retyped several
       times to an end-point 

       The comparison function for a singleton ptr, the formula is
       simply:
       "parent->ptr == child->ptr"
     **/

     retype_multi_to {
         EndPoint: { listener }
     };

     /**
       We allow the use of unknow structures. However, equality will
       be defined by address, not by structure.
     **/

     eq "struct dcb" dcb;    /* Pointer to kernel DCB */
};

/** Then, we go back to routine **/

cap EndPoint {
     /* IDC endpoint */

     eq "struct dcb" listener;   /* Dispatcher listening on this endpoint */
     lvaddr  epoffset;          /* Offset of endpoint buffer in disp frame */
     uint32 epbuflen;          /* Length of endpoint buffer in words */
};


cap Frame {
     /* Mappable memory frame */

     retype_to { 
         Frame: { base, bits }
     };

     eq genpaddr base;         /* Physical base address of frame */
     eq uint8 bits;         /* Address bits this frame bears */
};

cap DevFrame {
     /* Mappable device frame */

     retype_to { 
         DevFrame: { base, bits }
     };

     eq genpaddr base;         /* Physical base address of frame */
     eq uint8 bits;         /* Address bits this frame bears */
};


cap Kernel {
     /* Capability to a kernel */
    is_always_copy;
};



/* x86_64-specific capabilities: */

cap VNode_x86_64_pml4 {
     /* PML4 */

     eq genpaddr base;         /* Base address of VNode */
};

cap VNode_x86_64_pdpt {
     /* PDPT */

     eq genpaddr base;         /* Base address of VNode */
};

cap VNode_x86_64_pdir {
     /* Page directory */

     eq genpaddr base;         /* Base address of VNode */
};

cap VNode_x86_64_ptable {
     /* Page table */

     eq genpaddr base;         /* Base address of VNode */
};


/* x86_32-specific capabilities: */

cap VNode_x86_32_pdpt {
     /* PDPT */

     eq genpaddr base;         /* Base address of VNode */
};

cap VNode_x86_32_pdir {
     /* Page directory */

     eq genpaddr base;         /* Base address of VNode */
};

cap VNode_x86_32_ptable {
     /* Page table */

     eq genpaddr base;         /* Base address of VNode */
};

/* ARM specific capabilities: */

cap VNode_ARM_l1 {
     /* L1 Page Table */
     eq genpaddr base;         /* Base address of VNode */
};

cap VNode_ARM_l2 {
     /* L2 Page Table */
     eq genpaddr base;         /* Base address of VNode */   
};

/** IRQTable and IO are slightly different **/

cap IRQTable {
     /* IRQ Routing table */

     /**
        When testing two IRQTable caps for is_copy,
     	in kernel/mdb.c,

	we always return True: all IRQ entries originate from a
	single, primitive Cap. Grand'pa Cap, sort of.
     **/

     is_always_copy;

     /* Empty payload*/
};

cap IO {
     /* Legacy IO capability */
     eq uint16 start;
     eq uint16 end;	 /* Granted IO range */
};

/* really RCK notify caps */
cap Notify_RCK {
    eq uint8 coreid;
    eq uint16 chanid;
};

/* IPI notify caps */
cap Notify_IPI {
    eq uint8 coreid;
    eq uint16 chanid;
};

cap Domain {
    /* Domain capability (opaque type, used by the monitors) */
    eq uint32 domainid;
};

cap PerfMon {
       is_always_copy;
};
